set ignoreTypes = false.
set traceDisplay = long.

type send_result.

const SendMsg: send_result.
const CorruptMsg: send_result.
const LostMsg: send_result.


free udata_c: channel [private].
free uack_c: channel [private].

free Payload: bitstring [private].
free ACK: bitstring [private].
free NACK: bitstring [private].

fun corrupt(bitstring): bitstring.

event evSenderSendResult(send_result).
event evReceiverRecvResult(bitstring).

event evSenderRepeat.
event evReceiverRepeat.


(* possible to receive corrupted payload *)
query x: bitstring; inj-event(evReceiverRecvResult(x)) && inj-event(evSenderSendResult(CorruptMsg)) ==> x = corrupt(Payload).

(* not possible to receive a lost message *)
query (inj-event(evReceiverRecvResult(Payload)) && inj-event(evSenderSendResult(LostMsg))).

(* on every corrupted packet need resend *)
query inj-event(evSenderRepeat) ==> inj-event(evReceiverRecvResult(corrupt(Payload))).


let rdt2_send(packet: bitstring) =
    new action: send_result;
    event evSenderSendResult(action);
    if action = SendMsg then
        out(udata_c, packet);
        in(uack_c, reply: bitstring);
        if reply = NACK then
            event evSenderRepeat
    else
        out(udata_c, corrupt(packet));
        in(uack_c, reply: bitstring);
        if reply = NACK then
            event evSenderRepeat.
        (* place for lost message *)


let rdt2_recv() =
    in(udata_c, packet: bitstring);
    event evReceiverRecvResult(packet);
    if packet = Payload then
        out(uack_c, ACK)
    else
        out(uack_c, NACK);
        event evReceiverRepeat.


(******************************************
 * rdt2.0 features: check checksum and ARQ
 *
 * not resistant to:
 * - packets drops
 * - bits corruptions in [N]ACKs
 *****************************************)
process !rdt2_send(Payload) | !rdt2_recv()
